### 进程控制

#### 创建子进程-fork

```c
#include <sys/types.h>
#include <unistd.h>

/**
  * @brief  创建子进程
  * @param  无
  * @retval 失败返回-1。成功返回两次，父进程返回子进程id，子进程返回0
  */
pid_t fork(void);
```

```c
#include <sys/types.h>
#include <unistd.h>

/**
  * @brief  获得当前进程id
  * @param  无
  * @retval 当前进程id
  */
pid_t getpid(void);
/**
  * @brief  获得当前进程的父进程id
  * @param  无
  * @retval 当前进程的父进程id
  */
pid_t getppid(void);
```

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(void) {
    for (int i = 0; i < 3; i++) {
        printf("%d  ", i);
        int pid = fork();
        if (pid > 0) {
            printf("父进程：pid = %d, ppid = %d, child_pid = %d\n", getpid(), getppid(), pid);
        }
        else if (pid == 0) {
            printf("子进程：pid = %d, ppid = %d\n", getpid(), getppid());
            // 为了阻止子进程再创建子进程，可以break跳出去
        }               
    }
    return 0;
}

/* 输出，每次循环都复制一遍，因此乘以2。如果父进程先死，子进程getppid()结果为1
0  父进程：pid = 56582, ppid = 39791, child_pid = 56583
0  子进程：pid = 56583, ppid = 56582
1  父进程：pid = 56582, ppid = 39791, child_pid = 56584
1  父进程：pid = 56583, ppid = 56582, child_pid = 56585
1  子进程：pid = 56585, ppid = 56583
2  父进程：pid = 56583, ppid = 56582, child_pid = 56586
2  父进程：pid = 56585, ppid = 56583, child_pid = 56587
2  子进程：pid = 56586, ppid = 1
2  子进程：pid = 56587, ppid = 1
1  子进程：pid = 56584, ppid = 56582
2  父进程：pid = 56584, ppid = 56582, child_pid = 56588
2  子进程：pid = 56588, ppid = 56584
2  父进程：pid = 56582, ppid = 39791, child_pid = 56589
2  子进程：pid = 56589, ppid = 56582
*/
```

```bash
ps			# 显示当前进程的状态
-aux		# 显示包含其他使用者的进程
-ajx		# 显示有ppid，可以进行追溯

kill		# 给进程发送信号
kill -9 pid # 彻底杀死进程pid
```

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(void) {
    int i = 0;
    for (i = 0; i < 10; i++) {
        printf("%d ", i);
        // 手动刷新stdout
        // fflush(stdout);
        int pid = fork();
        if (pid > 0) {
            // printf("父进程：pid = %d, ppid = %d, child_pid = %d\n", getpid(), getppid(), pid);
        }
        else if (pid == 0) {
            // printf("子进程：pid = %d, ppid = %d\n", getpid(), getppid());
            break;
        }       
    }
    // 控制子进程顺序
    sleep(i + 1);
    printf("进程%d: %d, 父进程: %d\n", i, getpid(), getppid());
    return 0;
}

/* 输出
0 进程0: 120698, 父进程: 120697
0 1 进程1: 120699, 父进程: 120697
0 1 2 进程2: 120700, 父进程: 120697
0 1 2 3 进程3: 120701, 父进程: 120697
0 1 2 3 4 进程4: 120702, 父进程: 120697
0 1 2 3 4 5 进程5: 120703, 父进程: 120697
0 1 2 3 4 5 6 进程6: 120704, 父进程: 120697
0 1 2 3 4 5 6 7 进程7: 120705, 父进程: 120697
0 1 2 3 4 5 6 7 8 进程8: 120706, 父进程: 120697
0 1 2 3 4 5 6 7 8 9 进程9: 120707, 父进程: 120697
0 1 2 3 4 5 6 7 8 9 进程10: 120697, 父进程: 108032
*/

/*
这里涉及到printf的知识：stdout的缓冲刷新机制
printf输出条件: 
	(1)调用fflush手动刷新
	(2)缓冲区满
	(3)遇到\n\r
	(4)遇到scanf需要取缓冲区的
	(5)线程或进程退出
printf是向stdout输出打印的东西的，而默认的stdout是line buffering，也就是行缓存的，即打印的东西不够一行时，这些信息保存在stdout的buffer中。当fork时，父子进程的stdout都保有未打印的buffer
*/
```

fork的子进程与父进程异同：

相同：全局变量、代码段、数据的、栈、堆、环境变量、用户id、宿主目录、进程工作目录、信号处理方式…

不同：进程id，fork返回值、父进程id、进程运行时间、闹钟（定时器）、未决信号集

但是，难道fork的子进程完全拷贝父进程的用户空间，然后映射到物理内存？很明显没有，浪费内存

父子进程遵循读时共享，写时复制的原则

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int var = 100;

int main(void) {
    pid_t pid = fork();
    if(pid == 0) {
        // son
        printf("child: var = %d,var_p = %p, *var_p = %d\n", var, &var, *(&var));
        sleep(1);
        var = 101;
        printf("child: var = %d,var_p = %p, *var_p = %d\n", var, &var, *(&var));
    }
    else if(pid > 0) {
        // parent
        printf("parent: var = %d,var_p = %p, *var_p = %d\n", var, &var, *(&var));
        sleep(2);
        printf("parent: var = %d,var_p = %p, *var_p = %d\n", var, &var, *(&var));
    }
    return 0;
}

/*
parent: var = 100,var_p = 0x560591ba6010, *var_p = 100
child: var = 100,var_p = 0x560591ba6010, *var_p = 100
child: var = 101,var_p = 0x560591ba6010, *var_p = 101
parent: var = 100,var_p = 0x560591ba6010, *var_p = 100
*/

/*
fork时子进程获得父进程用户空间的拷贝，所以变量地址（虚拟地址）一致。但linux采用写时复制，fork后两个虚拟地址指向相同的物理地址，当任何一个进程试图修改该虚拟地址的内容时，这两个虚拟地址才指向不同的物理空间。
fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用
*/
```

#### exec族函数

```c
#include <unistd.h>

// 执行其他程序
int execl(const char *pathname, const char *arg, .../* (char  *) NULL 作为哨兵，提示参数列表完毕 */);
// 执行其他程序，借助环境变量
int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
int execle(const char *pathname, const char *arg, .../*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);

/*
	exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。
	与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行
*/

/*
execl | execlp:
参数1是要加载的程序的名字，参数2是argv[0]，argv[1]...最后一个参数是NULL
第二个参数argv[0]可以随便写，但其他的不可以随便写
*/
// ls -l 命令
execl("/bin/ls", "ls", "-l", NULL);
execlp("ls", "ls", "-l", NULL);
```

#### 孤儿进程与僵尸进程

孤儿进程：父进程死了，子进程被init进程领养

僵尸进程：子进程死了，父进程没有回收子进程的PCB

```c
// 孤儿进程
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(void) {
    pid_t pid = fork();
    if(pid == 0) {
        printf("I am child, ppid = %d\n", getppid());
        sleep(2);
        printf("I am child, ppid = %d\n", getppid());
    }
    else if(pid > 0) {
        sleep(1);
        printf("parent killed\n");
    }
    return 0;
}

/*
I am child, ppid = 178127
parent killed
I am child, ppid = 1
*/

/*
如果子进程while循环，crtl+c无法结束，因为子进程已经被init接管，只能用kill杀死
*/
```

```c
// 僵尸进程
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(void) {
    pid_t pid = fork();
    if(pid == 0) {
        printf("I am child, pid = %d, ppid = %d\n", getpid(), getppid());
        sleep(1);
        printf("child killed\n");
    }
    else if(pid > 0) {
        while(1) {
            printf("I am parent, pid = %d\n", getpid());
            sleep(20);
        }
    }
    return 0;
}

/*
使用ps -aux可以看到子进程没有被回收
kill -9 无法杀死
只有杀死父进程，由init领养后，负责回收僵尸进程
*/
```

#### wait函数

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);

/*
进程一旦调用了wait，就会立刻阻塞自己，由wait分析当前进程中的某个子进程是否已经退出了，如果让它找到这样一个已经变成僵尸进程的子进程，wait会收集这个子进程的信息，并将它彻底销毁后返回；如果没有找到这样一个子进程，wait会一直阻塞直到有一个出现。
参数wstatus用来保存被收集进程退出时的一些状态，它是一个指向int型的指针。但如果对这个子进程是如何死掉的不在乎，咱们可以将它设置为NULL：pid = wait(NULL);如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用会失败，wait返回-1，同时errno会被设置
wait在第一个子进程退出后立刻结束阻塞状态
*/

/* wstatus
WIFEXITED(wstatus)：正常死亡
WEXITSTATUS(wstatus)：正常死亡的情况下，获得退出状态，即return返回值，或exit返回值
WIFSIGNALED(wstatus)：非正常死亡
WTERMSIG(wstatus)：得到死亡原因，即kill -option 的option
*/

/*
pid < -1	等待进程组号为pid绝对值的任何子进程
pid = -1	等待任何子进程，这时候waitpid退化为wait
pid = 0		等待进程组号与目前进程相同的任何子进程，即任何和调用waitpid函数的进程在同一个进程组的进程
pid > 0  	等待进程号为pid的子进程
*/

/* option
0			进入阻塞状态
WNOHANG		如果pid指定的子进程没有结束，则waitpid立刻返回0，而不是阻塞等待。如果结束了，则返回子进程的pid
WUNTRACED	如果子进程进入暂停状态，则立刻返回
*/
```

```c
// 判断进程死亡状态
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    pid_t pid = fork();
    if(pid == 0) {
        printf("I am child, pid = %d, ppid = %d\n", getpid(), getppid());
        sleep(1);
        printf("child killed\n");
        return 101;
    }
    else if(pid > 0) {
        printf("I am parent, child_pid = %d\n", pid);
        int status;
        pid_t child_pid = wait(&status);
        printf("I am parent, child_pid = %d\n", child_pid);
        if(WIFEXITED(status)) {
            printf("正常死亡，%d\n", WEXITSTATUS(status));
        }
        if(WIFSIGNALED(status)) {
            printf("被信号杀死，%d\n", WTERMSIG(status));
        }
    }
    return 0;
}
```

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    pid_t pid = fork();
    if(pid == 0) {
        printf("I am child, pid = %d, ppid = %d\n", getpid(), getppid());
        sleep(1);
        while(1) sleep(20);
        return 101;
    }
    else if(pid > 0) {
        printf("I am parent, child_pid = %d\n", pid);
        int status;
        pid_t child_pid = wait(&status);
        printf("I am parent, child_pid = %d\n", child_pid);
        if(WIFEXITED(status)) {
            printf("正常死亡，%d\n", WEXITSTATUS(status));
        }
        if(WIFSIGNALED(status)) {
            printf("被信号杀死，%d\n", WTERMSIG(status));
        }
    }
    return 0;
}
```

### 进程间通信（IPC）

通过内核提供的缓冲区进行数据交换

IPC通信的方式：

- pipe：管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。针对有血缘关系的进程
- FIFO：匿名管道由于没有名字，只能用于血缘进程间的通信。为了克服这个缺点，提出了有名管道，也称做 FIFO，因为数据是先进先出的传输方式。所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信
- mmap：存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现
- 消息队列
- 本地socket
- 信号量
- 共享内存

#### PIPE——管道

##### 简介

所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称 pipe 文件

向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；而接收管道输出的接收进程（即读进程），可从管道中接收数据。由于发送进程和接收进程是利用管道进行通信的，故又称管道通信

管道是**半双工通信**，同一个时刻数据流向只有一个

为了协调双方的通信，管道通信机制必须提供以下3 方面的协调能力。

- 互斥。当一个进程正在对 pipe 进行读/写操作时，另一个进程必须等待
- 同步。当写（输入）进程把一定数量（如4KB）数据写入 pipe 后，便去睡眠等待，直到读（输出）进程取走数据后，再把它唤醒。当读进程读到一空 pipe 时，也应睡眠等待，直至写进程将数据写入管道后，才将它唤醒
- 对方是否存在。只有确定对方已存在时，才能进行通信

##### 读写行为

读端：

- 写端全部关闭——read读到0，相当于读到文件末尾
- 写端没有全部关闭
	- 有数据——read读到数据
	- 没有数据——read阻塞，fcntl函数可以更改阻塞

写端：

- 读端全部关闭——产生一个信号SIGPIPE，程序异常终止
- 读端没有全部关闭
	- 管道已满——write阻塞
	- 管道没满——write正常写入

##### 管道大小

ulimit -a 获取内核区大小

```c
#include <unistd.h>

/**
  * @brief  创建管道
  * @param  pipefd，其中pipefd[0]是读，pipefd[1]是写
  * @retval 失败返回-1。成功返回0
  */
int pipe(int pipefd[2]);
```

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(void) {
    int fd[2];
    pipe(fd);
    pid_t pid = fork();
    if(pid == 0) {
        char buf[256];
        // 读，阻塞
        read(fd[0], buf, sizeof(buf));
        printf("read: %s\n", buf);
    }
    else if(pid > 0){
        sleep(1);
        char buf[256] = "hello world";
        printf("write: %s\n", buf);
        // 写
        write(fd[1], buf, sizeof(buf));
    }
    return 0;
}
```
```c
// 父子进程的文件描述符不共享，因此需要在fork之前创建管道
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(void) {
    int fd[2];
    pipe(fd);
    pid_t pid = fork();
    if(pid == 0) {
        printf("child %d\n", open("a", O_RDWR | O_CREAT, 0666));
    }
    else if(pid > 0){
        printf("parent %d\n", open("b", O_RDWR | O_CREAT, 0666));
    }
    return 0;
}
```
```c
// ps -aux | grep bash
#include <stdio.h>
#include <unistd.h>

int main(void) {
    int fd[2];
    pipe(fd);
    pid_t pid = fork();
    if(pid == 0) {
        // child --> ps
        // sleep(1);
        // 关闭读端
        close(fd[0]);
        // write(fd[1], "bash\nbash1\n", 11);
        // 重定向，标准输出重定向到write端
        dup2(fd[1], STDOUT_FILENO);
        // execlp
        execlp("ps", "ps", "-aux", NULL);
    }
    else if(pid > 0){
        // parent --> grepo
        // 关闭写端
        close(fd[1]);
        // 重定向，标准输入重定向到read端
        dup2(fd[0], STDIN_FILENO);
        // execlp
        // grep bash 从标准输入获取数据，并过滤出bash，因此即使子进程等了1s再发数据，grep依旧阻塞在这里
        // grep一直从标准输入获取数据，所以会一直等待，直到写端全部关闭，读端相当于读到文件末尾，结束grep
        // 如果子进程先发数据，那么父进程也可以从标准输入获取数据
        execlp("grep", "grep", "bash", NULL);
    }
    return 0;
}
```

#### FIFO——有名管道

##### 简介

匿名管道由于没有名字，只能用于血缘进程间的通信。为了克服这个缺点，提出了有名管道，也称做 FIFO，因为数据是先进先出的传输方式。所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信

##### 创建管道伪文件

```bash
mkfifo myfifo		# shell创建
```

```c
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
```

##### 操作FIFO

内核会针对FIFO文件开辟一个缓冲区，用读写文件方式即可操作

open注意事项，打开FIFO文件时，只有读端或写端时，会阻塞等待另外一端打开

```c
// 写进程
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(void) {
    printf("begin open---\n");
    int fd = open("myfifo", O_WRONLY);
    printf("end open---\n");
    write(fd, "hello\nhello1\n", 14);
    return 0;
}
```

```c
// 读进程
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(void) {
    printf("begin open---\n");
    int fd = open("myfifo", O_RDONLY);
    printf("end open---\n");
    char buf[12]={0};
    int i = 0;
    while(1){
        memset(buf, 0x00, sizeof(buf));
        int ret = read(fd, buf, sizeof(buf));
        if (ret == 0) break;
        printf("%s", buf);
    }
    
    return 0;
}
```

#### MMAP——存储映射

##### 简介

存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现

##### 创建映射区

```c
#include <sys/mman.h>

/**
  * @brief  创建映射区
  * @param  addr    指定映射的虚拟内存地址，一般传NULL，由内核自动选择合适的虚拟内存地址
  * @param	length	映射区长度
  * @param	prot	映射内存的保护模式，可选值如下
  					- PROT_EXEC		可被访问
  					- PROT_READ		可读
  					- PROT_WRITE 	可写
  					- PROT_NONE		不可访问
  * @param	flags	指定映射的类型，常用可选值如下
  					- MAP_SHARED	与其他所有映射到该文件的进程共享映射空间（用于IPC），写时立刻修改源文件
  					- MAP_PRIVATE	建立一个写时复制的私有映射空间，写时不修改源文件
  					- MAP_ANON		映射不需要依赖某个文件，忽略fd参数，fd参数必须为-1，且offset应为0，也可写为
  									MAP_ANONYMOUS
  * @param	fd		文件描述符
  * @param	offset	文件偏移量（从文件的何处开始映射）
  * @retval 成功返回可用的内存地址，失败返回MAP_FAILED
  */
void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);

/**
  * @brief  释放映射区
  * @param  addr    映射的虚拟内存地址，mmap的返回值
  * @param	length	创建的映射区长度
  * @retval 成功返回0，失败返回-1
  */
int munmap(void *addr, size_t length);
```

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>

int main(void) {
    int fd = open("mem.txt", O_RDWR | O_CREAT, 0666);
    int mmap_size = 128;
    // 获取文件状态，判断文件大小是否大于mmap需要的大小
    struct stat sb;
    fstat(fd, &sb);
    int file_size = sb.st_size;
    if(file_size < mmap_size){
        printf("文件大小小于映射区需要大小，扩展文件\n");
        // 扩展文件
        ftruncate(fd, mmap_size);
    }
    // 获取mmap映射地址，flags改为MAP_PRIVATE不会改变源文件
    char *mem = (char *)mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if(mem == MAP_FAILED){
        perror("mmap err");
        return -1;
    }
    strcpy(mem, "hello\nworld\n");
    // 释放mmap
    munmap(mem, mmap_size);
    close(fd);
    return 0;
}
```

##### 常见问题

1. 修改了mem变量的地址（如：mem++），使用munmap释放映射区会报错，Invalid argument
2. 对mem进行越界操作，即写入的字符大于mmap映射区的长度时，只截取文件大小的字符。如果文件大小为0，则报错。所以最好mmap映射区小于文件大小，且写入的字符也小于mmap映射区
3. mmap时offset不能随便填一个数，否则创建映射区失败。offset必须是4K的整数倍，最小IO块为4K
4. 如果文件描述符先关闭，对mmap映射没有影响。映射完之后文件已经没有用
5. open的时候可以新建一个文件吗？可以，但需要对文件大小进行扩展
6. open的时候不可以选择WR_ONLY，Permission denied。因为mmap映射过程中需要读操作。同理，当mmap中flags选择MAP_SHARED，且prot选择PROT_WRITE时，也没有权限。所以open的时候文件权限要大于mmap时的权限

##### mmap实现父子进程通信

```c
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>

int main(void) {
    // 将文件大小置为0，然后扩展文件到指定映射区大小
    int fd = open("mem.txt", O_RDWR | O_CREAT | O_TRUNC, 0666);
    int mmap_size = 128;
    ftruncate(fd, mmap_size);
    // 获取mmap映射地址
    int *mem = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if(mem == MAP_FAILED){
        perror("mmap err");
        return -1;
    }
    
    // 创建子进程
    pid_t pid = fork();
    if(pid == 0){
        // child
        mem[0] = 100;
        printf("child, mem[0] = %d\n", mem[0]);
        sleep(3);
        printf("child, mem[0] = %d\n", mem[0]);
    }
    else if(pid > 0){
        // parent
        sleep(1);
        printf("parent, mem[0] = %d\n", mem[0]);
        mem[0] = 1001;
        printf("parent, mem[0] = %d\n", mem[0]);
        wait(NULL);
    }

    // 释放mmap
    munmap(mem, mmap_size);
    close(fd);
    return 0;
}

/*
child, mem[0] = 100
parent, mem[0] = 100
parent, mem[0] = 1001
child, mem[0] = 1001
*/
```

##### 匿名映射

每次创建映射区的时候一定要依赖某个文件，即open文件后还要关闭，也可能产生一些不必要的文件，非常麻烦。这时候就可以采用匿名映射的方式来创建映射区

```c
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>

int main(void) {
    int mmap_size = 128;
    // 获取mmap映射地址
    int *mem = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if(mem == MAP_FAILED){
        perror("mmap err");
        return -1;
    }
    
    // 创建子进程
    pid_t pid = fork();
    if(pid == 0){
        // child
        mem[0] = 100;
        printf("child, mem[0] = %d\n", mem[0]);
        sleep(3);
        printf("child, mem[0] = %d\n", mem[0]);
    }
    else if(pid > 0){
        // parent
        sleep(1);
        printf("parent, mem[0] = %d\n", mem[0]);
        mem[0] = 1001;
        printf("parent, mem[0] = %d\n", mem[0]);
        wait(NULL);
    }

    // 释放mmap
    munmap(mem, mmap_size);
    return 0;
}
```

##### mmap实现无血缘进程通信

```c
// 写进程
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>

typedef struct People{
    int age;
    char name[20];
}People;

int main(void) {
    int fd = open("temp", O_RDWR | O_CREAT | O_TRUNC, 0666);
    ftruncate(fd, sizeof(People));
    // 获取mmap映射地址
    People *people = mmap(NULL, sizeof(People), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if(people == MAP_FAILED){
        perror("mmap err");
        return -1;
    }
    int num = 1;
    while(1){
        people->age = num;
        sprintf(people->name, "LiHua-%03d", num++);
        sleep(1);
    }
    // 释放mmap
    munmap(people, sizeof(People));
    close(fd);
    return 0;
}
```

```c
// 读进程
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>

typedef struct People{
    int age;
    char name[20];
}People;

int main(void) {
    int fd = open("temp", O_RDWR | O_CREAT | O_TRUNC, 0666);
    ftruncate(fd, sizeof(People));
    // 获取mmap映射地址
    People *people = mmap(NULL, sizeof(People), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if(people == MAP_FAILED){
        perror("mmap err");
        return -1;
    }
    while(1){
        sleep(1);
        printf("age: %d, name: %s\n", people->age, people->name);
    }
    // 释放mmap
    munmap(people, sizeof(People));
    close(fd);
    return 0;
}
```

### 信号

#### 简介
信号可以看成一个软件中断，可以用kill -l命令查看信号种类

**信号的产生**
- 按键产生：crtl+c、crtl+z、crtl+\
- 系统调用函数：kill、raise、abort
- 定时器alarm、setitimer
- 硬件中断：段异常、浮点型错误等等

 **信号的状态**
- 产生
- 递达：信号到达且被处理完
- 未决：信号被阻塞

**信号的默认处理方式**
- 忽略
- 执行默认动作
- 捕获（调用用户函数），其中9（SIGKILL），19（SIGSTOP）号信号不能捕获、不能忽略，也不能阻塞

**信号的4要素**
- 编号
- 事件
- 名称
- 默认处理动作，忽略、终止、终止且产生core、暂停、继续

**阻塞信号集(信号屏蔽字)**
将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)

**未决信号集**

1. 信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 
2. 信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态

**信号捕捉特性**

1. 进程正常运行时，默认PCB存在一个信号屏蔽字，假设为A，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号后，要调用该函数。而该函数执行时间可能很长，这期间所屏蔽的信号不由A决定，而是sa_mask所指定。该函数执行完后，再恢复为A
2. xxx信号捕捉函数执行期间，xxx信号被自动屏蔽
3. 阻塞的常规信号不支持排队，产生多次信号也只记录一次（后32个实时信号支持排队）

#### Linux常规信号一览表

1. SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程
2. SIGINT：当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动

作为终止进程

3. SIGQUIT：当用户按下<ctrl+\\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信

号。默认动作为终止进程

4. SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件

5. SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件

6. SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件

7. SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件

8. SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件

9. SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法

10. SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程

11. SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件

12. SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程

13. SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程

14. SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程

15. SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。

16. SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。

17. SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。

18. SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。

19. SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。

20. SIGTSTP：停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号。默认动作为暂停进程。

21. SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。

22. SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。

23. SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。

24. SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。

25. SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。

26. SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。

27. SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。

28. SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。

29. SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。

30. SIGPWR：关机。默认动作为终止进程。

31. SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。

34. SIGRTMIN ～ 64. SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程

#### 系统调用函数产生信号

##### kill

```c
#include <sys/types.h>
#include <signal.h>

/**
  * @brief  给指定进程发送信号
  * @param  pid	信号发送的进程
  			pid > 0		pid指定的进程
  			pid = 0 	调用进程的进程组内的每个进程
  			pid = -1	调用进程有权限发送信号的每个进程，但不包括init进程（进程1）
  			pid < -1	进程组ID为-pid内的每个进程
  * @param  sig	发送的信号，可以用man 7 signal查看
  * @retval 失败返回-1。成功返回0
  */
int kill(pid_t pid, int sig);
```

```c
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <signal.h>

int main(void) {
    int i = 0;
    for(i = 0; i < 5; i++){
        pid_t pid = fork();
        if(pid == 0) break;
    }
    if(i == 2){
        // 子进程发送SIGKILL(9)杀死父进程
        printf("I will kill father after 5s\n");
        sleep(5);
        kill(getppid(), SIGKILL);
        while(1){
            sleep(1);
        }
    }
    else if(i == 5){
        while(1){
            printf("I am father\n");
            sleep(1);
        }
    }
    return 0;
}
```

##### raise

```c
#include <signal.h>

/**
  * @brief  给调用进程或线程发送信号，等同于 kill(getpid(), sig) 或 pthread_kill(pthread_self(), sig)
  * @param  sig	发送的信号，可以用man 7 signal查看
  * @retval 失败返非零值。成功返回0
  */
int raise(int sig);
```

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main(void) {
    printf("I will die\n");
    sleep(2);
    raise(SIGKILL);
    return 0;
}
```

##### abort

```c
#include <stdlib.h>

/**
  * @brief  给调用进程发送SIGABRT(3)信号，导致异常进程终止
  * @param  无
  * @retval 无
  */
void abort(void);
```

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(void) {
    printf("I will abort\n");
    sleep(2);
    abort();
    return 0;
}
```

#### 定时器产生信号

##### alarm

```c
#include <unistd.h>

/**
  * @brief  在 seconds 秒后将一个 SIGALRM(14) 信号发送给调用进程，设置一个定时器，且取消之前的定时器（一个进程只有一个定时器）
  * @param  seconds
  			seconds > 0	发送的时间
  			seconds = 0	取消先前设置的定时器
  * @retval 返回先前设定的定时器触发的剩余秒数，如果之前没有计划的定时器，则返回零。
  */
unsigned int alarm(unsigned int seconds);
```

```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
    printf("alarm 0: %d\n", alarm(3));
    sleep(4);
    printf("alarm 1: %d\n", alarm(3));
    return 0;
}
```

##### setitimer

```c
#include <sys/time.h>

/**
  * @brief  获取指定的定时器的当前值，存放在curr_value中
  * @param  which	选择定时器类型，可选值如下：
  			ITIMER_REAL		真实时间作为倒计时，到期产生SIGALRM信号
  			ITIMER_VIRTUAL	用户空间下进程消耗的CPU时间作为倒计时，到期产生SIGVTALRM信号
  			ITIMER_PROF		进程消耗的总CPU时间（用户和内核）作为倒计时，到期产生SIGPROF信号
  * @retval 成功返回0，失败返回-1且设置errno
  */
int getitimer(int which, struct itimerval *curr_value);

/**
  * @brief  设置定时器
  * @param  which		选择定时器类型，可选值如下：
  			ITIMER_REAL		真实时间作为倒计时，到期产生SIGALRM(14)信号
  			ITIMER_VIRTUAL	用户空间下进程消耗的CPU时间作为倒计时，到期产生SIGVTALRM(26)信号
  			ITIMER_PROF		进程消耗的总CPU时间（用户和系统）作为倒计时，到期产生SIGPROF(27)信号
  *	@param  new_value	设置定时器的新值，可以启动或解除which指定的定时器，参考itimerval
  * @param  old_value	非空获取定时器的旧值，即与getitimer相同。一般设置为NULL
  * @retval 成功返回0，失败返回-1且设置errno
  */
int setitimer(int which, const struct itimerval *new_value,
              struct itimerval *old_value);

struct itimerval {
    struct timeval it_interval; /* 周期定时器的间隔。如果it_interval两个字段都为0，说明这是一个单次定时器（即它在到期时过期） */
    struct timeval it_value;    /* 距离下一次到期的时间。定时器到期后重置为it_interval。如果it_value两个字段都为0，说明定时器当前处于非活动状态 */
};

struct timeval {
    time_t      tv_sec;         /* 秒 */
    suseconds_t tv_usec;        /* 微秒 */
};
```

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>

void printf_info(const struct itimerval * const timer){
    printf("timer interval: %lds %ldus\n", timer->it_interval.tv_sec, timer->it_interval.tv_usec);
    printf("timer value: %lds %ldus\n", timer->it_value.tv_sec, timer->it_value.tv_usec);
}

int main(void) {
    struct itimerval timer = {{0, 0}, {3, 0}};
    struct itimerval old_timer;
    setitimer(ITIMER_REAL, &timer, NULL);
    while(1){
        getitimer(ITIMER_REAL, &old_timer);
        printf_info(&old_timer);
        sleep(1);
    }
    return 0;
}
```

#### 信号集处理函数

```c
#include <signal.h>

/**
  * @brief  将给定的信号集set初始化为空，将所有信号从集合中排除
  *	@param  set 信号集，sigset_t 类型的对象在传递给 sigaddset()、sigdelset() 和 sigismember() 函数或其他一些额外的函数之前，必须通过调用 sigemptyset() 或 sigfillset() 进行初始化。如果没有进行初始化，则行为是未定义的
  * @retval 成功时返回0，失败时返回-1，且设置errno
  */
int sigemptyset(sigset_t *set);

/**
  * @brief  将set初始化为全集，包括所有信号
  *	@param  set 信号集
  * @retval 成功时返回0，失败时返回-1，且设置errno
  */
int sigfillset(sigset_t *set);

/**
  * @brief  向set中添加信号signum
  *	@param  set 	信号集
  * @param	signum	信号
  * @retval 成功时返回0，失败时返回-1，且设置errno
  */
int sigaddset(sigset_t *set, int signum);

/**
  * @brief  向set中删除信号signum
  *	@param  set 	信号集
  * @param	signum	信号
  * @retval 成功时返回0，失败时返回-1，且设置errno
  */
int sigdelset(sigset_t *set, int signum);

/**
  * @brief  检查signum是否是set的成员
  *	@param  set 	信号集
  * @param	signum	信号
  * @retval 如果signum是set的成员，则返回1，如果signum不是成员，则返回0，出错时返回-1，设置errno
  */
int sigismember(const sigset_t *set, int signum);


/**
  * @brief  设置阻塞或者解除阻塞信号集
  *	@param  how 	信号集，可选值如下
  			SIG_BLOCK	设置set阻塞
  			SIG_UNBLOCK	解除set阻塞
  			SIG_SETMASK	设置set为新的阻塞信号集
  *	@param  set		信号集
  * @param	oldset	旧的信号集，可以用来恢复原来状态
  * @retval 成功时返回0，失败时返回-1，且设置errno
  */
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

/**
  * @brief  获取未决信号集
  *	@param  set	当前的未决信号集
  * @retval 成功时返回0，失败时返回-1，且设置errno
  */
int sigpending(sigset_t *set);
```

```c
// 打印未决信号集
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>

int main(void) {
    // 设置阻塞信号，等待按键产生信号
    sigset_t sigproc;
    sigemptyset(&sigproc);
    sigaddset(&sigproc, SIGINT);
    sigaddset(&sigproc, SIGQUIT);
    sigaddset(&sigproc, SIGTSTP);
    // 设置阻塞信号集
    sigprocmask(SIG_BLOCK, &sigproc, NULL);
    // 循环获取未决信号集
    while(1){
        sigset_t pend;
        sigpending(&pend);
        for(int i = 1; i< 32; i++){
            if(sigismember(&pend, i) == 1){
                printf("%d ", i);
            }
        }
        printf("\n");
        sleep(1);
    }
    return 0;
}
```



#### 捕获信号

##### signal

```c
#include <signal.h>

// 这行代码是一个类型定义（typedef），它定义了一个名为 sighandler_t 的新类型，该类型是一个指向接受一个整数参数并返回 void 类型的函数指针。
typedef void (*sighandler_t)(int);

/**
  * @brief  将信号 signum 的处理方式设置为 handler
  *	@param  signum	信号
  * @param  handler	信号处理方式，可选值如下
  			SIG_IGN			忽略信号
  			SIG_DFL			执行与信号相关的默认操作
  			用户函数地址		执行用户函数
  * @retval 返回信号处理程序的先前值，或者在出错时返回SIG_ERR，且设置errno
  */
sighandler_t signal(int signum, sighandler_t handler);
```

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>

void catch_signal(int sig){
    printf("cat %d signal\n", sig);
}

int main(void) {
    // 设置SIGALRM默认处理方式
    signal(SIGALRM, catch_signal);
    struct itimerval timer = {{3, 0}, {5, 0}};  // 第一次5s，之后周期为3s
    setitimer(ITIMER_REAL, &timer, NULL);
    while(1){
        sleep(1);
    }
    return 0;
}
```

##### sigaction

```c
#include <signal.h>

/**
  * @brief  用于更改进程在接收到特定信号时所采取的操作
  *	@param  signum	信号
  * @param  act		从act安装信号signum的新操作。
  * @param  oldact	如果oldact非空，则将之前的操作保存在oldact
  * @retval 成功返回0，失败返回-1，设置errno
  */
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);

struct sigaction {
    void     (*sa_handler)(int);	// 捕捉信号后执行的程序
    void     (*sa_sigaction)(int, siginfo_t *, void *);	// 捕捉信号后执行的程序，携带附加信息siginfo_t
    sigset_t   sa_mask;				// 执行捕捉函数期间，临时屏蔽的信号集
    int        sa_flags;			// 一般置0，使用sa_handler，置SA_SIGINFO时使用sa_sigaction
    void     (*sa_restorer)(void);	// 无效参数
};
```

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>

void catch_sig(int sig){
    printf("cat %d sig\n", sig);
    // 该期间crtl+c不会立刻退出，等到catch_sig结束后才执行SIGINT信号动作
    sleep(5);
}

int main(void) {
    // 注册捕捉函数
    struct sigaction act;
    act.sa_flags = 0;
    act.sa_handler = catch_sig;
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGINT);    //crtl+c
    sigaction(SIGALRM, &act, NULL);

    // 周期发送SIGALRM信号
    struct itimerval myit = {{3, 0}, {1, 0}};
    setitimer(ITIMER_REAL, &myit, NULL);
    while(1){
        sleep(1);
    }
    return 0;
}
```

```c
// 子进程在暂停或终止状态会发送SIGCHLD信号给父进程，可以通过捕捉该信号来回收子进程，避免一直等待
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>

void catch_sig(int sig){
    pid_t wpid;
    // 为了防止捕捉函数期间多个子进程死亡，只接收到一个SIGCHLD信号，可以在捕捉函数里面回收多个子进程
    while((wpid = waitpid(-1, NULL, WNOHANG)) > 0){
        printf("wait child %d ok\n", wpid);
    }
}

int main(void) {
    // 在创建子进程之前屏蔽SIGCHLD关键字
    sigset_t myset, oldset;
    sigemptyset(&myset);
    sigaddset(&myset, SIGCHLD);
    // oldset保存现场
    sigprocmask(SIG_BLOCK, &myset, &oldset);
    int i = 0;
    for(i = 0; i < 10; i++){
        if(fork() == 0){
            break;
        }
    }
    if(i == 10){
        // fathe
        // 模拟注册晚于子进程死亡
        sleep(2);
        // 注册捕捉函数
        struct sigaction act;
        act.sa_flags = 0;
        act.sa_handler = catch_sig;
        sigemptyset(&act.sa_mask);
        sigaction(SIGCHLD, &act, NULL);
        // 解除SIGCLED屏蔽
        sigprocmask(SIG_SETMASK, &oldset, NULL);
        while(1){
            sleep(1);
        }
    }
    else if(i < 10){
        // son
        // 给父进程注册捕捉函数的时间，否则第一个子进程结束的时候父进程还没有注册，导致回收子进程数变少
        // sleep(i + 1);
        printf("I am %d child, pid = %d\n", i, getpid());
    }
    return 0;
}
```

### 守护进程

#### 进程组

进程组，也称为作业。进程组的概念被提出来是为了简化对多个进程的管理。当父进程创建子进程时，默认父子进程同属于一个进程组，且进程组ID == 第一个进程ID（组长进程）。可以采用kill -SIGKILL -1*进程组ID杀死整个进程组内的所有进程。进程组生存周期为进程组创建直到最后一个进程离开（终止或转移到其他进程组），与组长进程是否存在无关

#### 会话

一般一个用户登录后新建一个会话，每个会话也有一个ID来标识（SID）。登录后的第一个进程叫做会话领头进程（session leader），通常是一个shell/bash。对于会话领头进程，其PID=SID。一般多个进程组对应一个会话

创建会话的注意事项：

- 调用进程不能是组长进程，是组长的话报错返回，然后该进程成为新会话的领头进程
- 该进程成为一个新进程组的组长进程
- 新会话丢掉原有的控制终端，该会话没有控制终端
- 建立新会话时，先调用fork，然后父进程终止，子进程调用setsid

##### 创建会话

```c
#include <sys/types.h>
#include <unistd.h>

/**
  * @brief 	调用进程成为新会话的领导者（即，其会话ID设置为其进程ID）。调用进程还成为会话中新进程组的进程组领导者（即，其进程组ID设置为其进程ID）
  *	@param  无
  * @retval 成功时，返回调用进程的（新）会话ID，失败返回-1，设置errno
  */
pid_t setsid(void);
```

##### 获取会话ID

```c
#include <sys/types.h>
#include <unistd.h>

/**
  * @brief 	获取进程的会话ID
  *	@param  pid	进程
  * @retval 成功时返回进程的会话ID，失败返回-1，设置errno
  */
pid_t getsid(pid_t pid);
```

#### 守护进程

守护进程是Linux中的后台服务进程，通常独立于控制终端且周期性执行某种任务或等待处理某些发生的事件，一般采用以d结尾的名字。Linux后台的一些系统服务进程，没有控制终端，不能与用户交互，也不受用户登录、注销的影响，一直在运行着，这些都是守护进程。如ftp服务器、nfs服务器等。创建守护进程，最关键的一步就是调用setsid函数创建一个新的Session，并成为新会话的领头进程

##### 创建守护进程

1. fork创建子进程，父进程退出
2. 子进程通过setsid新建会话，成为会长
3. 切换工作目录，一般$HOME，防止占用可卸载的文件系统（非必要）
4. 设置文件权限的掩码umask（非必要）
5. 关闭文件描述符0，1，2，防止浪费资源（非必要）
6. 执行守护进程的核心逻辑
7. 退出机制（非必要）

```c
// 创建守护进程，每隔60s新建一个文件
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <stdlib.h>

#define _FILE_NAME_FORMAT_ "%s/log/mydaemon.%ld"    // 定义文件格式

void touchfile(int num){
    char *HomeDir = getenv("HOME");
    char strFilename[250] = {0};
    sprintf(strFilename, _FILE_NAME_FORMAT_, HomeDir, time(NULL));
    int fd = open(strFilename, O_RDWR | O_CREAT, 0666);
    if(fd < 0){
        perror("open err");
        exit(1);
    }
    close(fd);
}

int main(void) {
    // 创建子进程，父进程退出
    pid_t pid = fork();
    if(pid > 0){
        exit(1);
    }
    // 创建会话
    setsid();
    // 切换工作目录
    chdir(getenv("HOME"));
    // 设置掩码
    umask(0);
    // 关闭文件描述符
    close(0), close(1), close(2);
    // 核心逻辑
    struct itimerval myit = {{60, 0}, {3, 0}};
    setitimer(ITIMER_REAL, &myit, NULL);
    struct sigaction act;
    act.sa_flags = 0;
    sigemptyset(&act.sa_mask);
    act.sa_handler = touchfile;
    sigaction(SIGALRM, &act, NULL);
    while(1){
        // 每隔一分钟创建文件
        sleep(1);
    }
    // 退出
    return 0;
}
```

```bash
nohup cmd [> 1.log] &		# 创建守护进程的命令方式，可以选择将输出重映射到1.log
# nohup 指令让程序cmd收不到SIGHUP指令
# & 代表后台运行
```

### 线程

#### 简介

可以理解为轻量级的进程。线程是最小的执行单位，而进程是最小的资源分配单位。主线程结束了，其他进程也

**线程共享资源**

- 文件描述符表
- 每种信号的处理方式
- 当前工作目录
- 用户ID和组ID
- 内存地址空间（.text/.data/.bss/heap/共享库）

**线程非共享资源**

- 线程ID
- 处理器现场和栈指针（内核栈）
- 独立的栈空间（用户空间栈）
- errno变量
- 信号屏蔽字
- 调度优先级

#### 线程控制原语

##### pthread_create——创建线程

```c
// 编译时候加 -pthread
#include <pthread.h>

/**
  * @brief 	创建一个新的线程
  *	@param  thread	新建线程的ID，传出参数
  *	@param  attr	线程的属性
  *	@param  参数3	   函数指针，线程的执行函数
  *	@param  arg		线程执行函数的参数，void*是一个跳跃力未定的指针，即可以为int*，也可以为char*
  * @retval 成功时返回0，失败返回errno
  */
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
```


##### pthread_self——获取自身线程ID

```c
#include <pthread.h>

/**
  * @brief 	获取调用线程自身ID
  *	@param  无
  * @retval 返回线程自身ID
  */
pthread_t pthread_self(void);
```

##### pthread_exit——线程退出

```c
#include <pthread.h>

/**
  * @brief 	调用线程退出，主线程调用pthread_exit退出，其他线程不会退出
  *	@param  retval	线程退出的返回值
  * @retval 无
  */
void pthread_exit(void *retval);
```

##### pthread_join——等待线程终止

```c
#include <pthread.h>

/**
  * @brief 	阻塞等待指定线程终止
  *	@param  thread	指定的线程ID
  *	@param  retval	线程终止的返回值
  * @retval 成功时返回0，失败返回errno
  */
int pthread_join(pthread_t thread, void **retval);
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void *thr(void *arg){
    printf("arg = %d\n", *(int *)arg);
    printf("I am a thread!pid = %d, tid = %ld\n", getpid(), pthread_self());
    sleep(1);
    // 分配动态内存，否则局部变量被销毁
    int *ret = malloc(sizeof(int));
    *ret = 1001;
    pthread_exit(ret);
    // return ret;
}

int main(void) {
    pthread_t tid;
    int arg = 101;
    pthread_create(&tid, NULL, thr, (void *)&arg);
    printf("I am a main thread, pid = %d, tid = %ld, thread_tid = %ld\n", getpid(), pthread_self(), tid);
    void *ret;
    pthread_join(tid, &ret);
    printf("pthread exit with %d\n", *(int *)ret);
    return 0;
}
```

##### pthread_cancel——杀死线程

```c
#include <pthread.h>

/**
  * @brief 	杀死线程
  *	@param  thread	指定的线程ID
  * @retval 成功时返回0，失败返回errno
  */
int pthread_cancel(pthread_t thread);
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void *thr(void *arg){
    while(1){
        // 注释下面代码，发现5s后线程不会被取消，是因为线程没有取消点
        // printf("I am a thread, tid = %ld\n", pthread_self());
        // sleep(1);
        // 强行设置取消点
        pthread_testcancel();
    }
    return NULL;
}

int main(void) {
    pthread_t tid;
    pthread_create(&tid, NULL, thr, NULL);
    sleep(5);
    pthread_cancel(tid);
    void *ret;
    pthread_join(tid, &ret);
    printf("thread exit with %d\n", (int)ret);	// 杀死进程退出状态为-1
    return 0;
}
```

##### pthread_detach——线程分离

```c
#include <pthread.h>

/**
  * @brief 	分离线程，该线程自动与主控线程断开关系。该线程一旦终止就立刻回收占用的资源，而不保留终止状态等待pthread_join获取，因此不能对一个分离线程使用pthread_join获取终止状态
  *	@param  thread	指定的线程ID
  * @retval 成功时返回0，失败返回errno
  */
int pthread_detach(pthread_t thread);
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

void *thr(void *arg){
    printf("I am a thread, tid = %ld\n", pthread_self());
    sleep(3);
    printf("I am a thread, tid = %ld\n", pthread_self());
    return NULL;
}

int main(void) {
    pthread_t tid;
    pthread_create(&tid, NULL, thr, NULL);
    pthread_detach(tid);    // 分离线程
    sleep(4);
    int ret = pthread_join(tid, NULL);
    // 打印错误信息
    if(ret > 0){
        printf("join err: %d, %s\n", ret, strerror(ret));
    }
    return 0;
}
```

##### 线程属性控制

```c
#include <pthread.h>

/**
  * @brief 	初始化线程属性
  *	@param  attr	线程属性
  * @retval 成功时返回0，失败返回errno
  */
int pthread_attr_init(pthread_attr_t *attr);

/**
  * @brief 	销毁线程属性
  *	@param  attr	线程属性
  * @retval 成功时返回0，失败返回errno
  */
int pthread_attr_destroy(pthread_attr_t *attr);

/**
  * @brief 	设置线程属性分离态
  *	@param  attr	x'c属性
  *	@param  detachstate	状态选择，可选值如下
  			PTHREAD_CREATE_DETACHED	使用attr创建的线程将以分离状态创建。
			PTHREAD_CREATE_JOINABL	使用attr创建的线程将以可连接状态创建，默认
  * @retval 成功时返回0，失败返回errno
  */
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
```

```c
// 线程创建的时候设置分离态
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

void *thr(void *arg){
    printf("I am a thread, tid = %ld\n", pthread_self());
    return NULL;
}

int main(void) {
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    pthread_t tid;
    pthread_create(&tid, &attr, thr, NULL);
    sleep(1);
    int ret = pthread_join(tid, NULL);
    // 打印错误信息
    if(ret > 0){
        printf("join err: %d, %s\n", ret, strerror(ret));
    }
    pthread_attr_destroy(&attr);
    return 0;
}
```

#### 线程同步

##### mutex相关函数

```c
#include <pthread.h>

/**
  * @brief 	初始化锁
  *	@param  mutex	锁，restrict代表mutex指向的内存空间只能由mutex指针去访问和修改
  *	@param  attr	锁的属性
  * @retval 成功时返回0，失败返回errno
  */
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);

// 常量初始化锁，这时候不需要用init
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

/**
  * @brief 	销毁锁
  *	@param  mutex	锁，restrict代表mutex指向的内存空间只能由mutex指针去访问和修改
  * @retval 成功时返回0，失败返回errno
  */
int pthread_mutex_destroy(pthread_mutex_t *mutex);

/**
  * @brief 	加锁。如果已经加锁，阻塞等待
  *	@param  mutex	锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_mutex_lock(pthread_mutex_t *mutex);

/**
  * @brief 	尝试加锁，但加锁失败也不会阻塞，继续运行下面代码
  *	@param  mutex	锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_mutex_trylock(pthread_mutex_t *mutex);

/**
  * @brief 	解锁
  *	@param  mutex	锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

```c
// pthread_mutex_lock 和 pthread_mutex_unlock
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *pthread1(void *arg){
    while(1){
        pthread_mutex_lock(&mutex);
        printf("hello ");
        sleep(rand() % 3);
        printf("world\n");
        pthread_mutex_unlock(&mutex);
        sleep(rand() % 3);
    }
    return NULL;
}

void *pthread2(void *arg){
    while(1){
        pthread_mutex_lock(&mutex);
        printf("HELLO ");
        sleep(rand() % 3);
        printf("WORLD\n");
        pthread_mutex_unlock(&mutex);
        sleep(rand() % 3);
    }
    return NULL;
}

int main(void) {
    pthread_t tid1, tid2;
    pthread_create(&tid1, NULL, pthread1, NULL);
    pthread_create(&tid2, NULL, pthread2, NULL);
    sleep(1);
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    return 0;
}
```

```c
// pthread_mutex_trylock
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *thr(void *arg){
    while(1){
        pthread_mutex_lock(&mutex);
        printf("hello world\n");
        sleep(30);
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main(void) {
    pthread_t tid;
    pthread_create(&tid, NULL, thr, NULL);
    sleep(1);
    while(1){
        int ret = pthread_mutex_trylock(&mutex);
        if(ret > 0){
            printf("ret = %d, srrmsg: %s\n", ret, strerror(ret));
        }
        sleep(1);
    }
    return 0;
}
```

##### 死锁

 **产生死锁的四个必要条件：**

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

##### 读写锁

读时共享，写时互斥。写的优先级高

```c
#include <pthread.h>

/**
  * @brief 	读写锁初始化
  *	@param  rwlock	读写锁
  *	@param  attr	读写锁的属性
  * @retval 成功时返回0，失败返回errno
  */
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                        const pthread_rwlockattr_t *restrict attr);

// 初始化读写锁
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

/**
  * @brief 	读写锁销毁
  *	@param  rwlock	读写锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

/**
  * @brief 	加读锁
  *	@param  rwlock	读写锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);

/**
  * @brief 	尝试加读锁
  *	@param  rwlock	读写锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);

/**
  * @brief 	加写锁
  *	@param  rwlock	读写锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);

/**
  * @brief 	尝试加写锁
  *	@param  rwlock	读写锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);

/**
  * @brief 	解锁
  *	@param  rwlock	读写锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

int begin_num = 1000;
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

void *thr_write(void *arg){
    while(1){
        pthread_rwlock_rdlock(&rwlock);
        printf("---%s---self---%lu---begin_num---%d---\n", __FUNCTION__, pthread_self(), ++begin_num);
        usleep(2000);
        pthread_rwlock_unlock(&rwlock);
        usleep(3000);
    }
    return NULL;
}

void *thr_read(void *arg){
    while(1){
        pthread_rwlock_rdlock(&rwlock);
        printf("---%s---self---%lu---begin_num---%d---\n", __FUNCTION__, pthread_self(), begin_num);
        usleep(2000);
        pthread_rwlock_unlock(&rwlock);
        usleep(3000);
    }
    return NULL;
}

int main(void) {
    int n = 8, i = 0;
    pthread_t tid[8]; //5-read, 3-write
    for(i = 0; i < 7; i++){
        pthread_create(&tid[i], NULL, thr_read, NULL);
    }
    for(i = 7; i < 8; i++){
        pthread_create(&tid[i], NULL, thr_write, NULL);
    }
    sleep(1);
    return 0;
}
```

##### 条件变量

通常的应用场景下，当前线程执行pthread_cond_wait时，处于临界区访问共享资源，存在一个mutex与该临界区相关联，这是理解pthread_cond_wait带有mutex参数的关键

当前线程执行pthread_cond_wait前，已经获得了和临界区相关联的mutex；执行pthread_cond_wait会阻塞，但是在进入阻塞状态前，必须释放已经获得的mutex，让其它线程能够进入临界区

当前线程执行pthread_cond_wait后，阻塞等待的条件满足，条件满足时会被唤醒；被唤醒后，仍然处于临界区，因此被唤醒后必须再次获得和临界区相关联的mutex

```c
#include <pthread.h>

/**
  * @brief 	条件变量初始化
  *	@param  cond	条件变量
  *	@param  attr	条件变量的属性
  * @retval 成功时返回0，失败返回errno
  */
int pthread_cond_init(pthread_cond_t *restrict cond,
                      const pthread_condattr_t *restrict attr);

// 初始化条件变量
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

/**
  * @brief 	条件变量销毁
  *	@param  cond	条件变量
  * @retval 成功时返回0，失败返回errno
  */
int pthread_cond_destroy(pthread_cond_t *cond);

/**
  * @brief 	超时等待，最多阻塞到abstime
  *	@param  cond	条件变量
  *	@param  mutex	锁
  *	@param  abstime	阻塞到的时间，真实时间
  * @retval 成功时返回0，失败返回errno
  */
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                           pthread_mutex_t *restrict mutex,
                           const struct timespec *restrict abstime);

/**
  * @brief 	阻塞等待
  *	@param  cond	条件变量
  *	@param  mutex	锁
  * @retval 成功时返回0，失败返回errno
  */
int pthread_cond_wait(pthread_cond_t *restrict cond,
                      pthread_mutex_t *restrict mutex);

/**
  * @brief 	唤醒至少一个阻塞在cond上的条件变量
  *	@param  cond	条件变量
  * @retval 成功时返回0，失败返回errno
  */
int pthread_cond_signal(pthread_cond_t *cond);

/**
  * @brief 	唤醒全部阻塞在cond上的条件变量
  *	@param  cond	条件变量
  * @retval 成功时返回0，失败返回errno
  */
int pthread_cond_broadcast(pthread_cond_t *cond);
```

```c
// 生产者-消费者模型
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

int begin_num = 1000;

typedef struct _ProdInfo{
    int num;
    struct _ProdInfo *next;
}ProdInfo;

// 产品
ProdInfo *head = NULL;

void *thr_productor(void *arg){
    // 负责在链表添加数据
    while(1){
        ProdInfo *prod = malloc(sizeof(ProdInfo));
        prod->num = begin_num++;
        pthread_mutex_lock(&mutex);
        // 添加产品
        prod->next = head;
        head = prod;
        printf("生产者%d, %04d\n", *(int *)arg, prod->num);
        pthread_mutex_unlock(&mutex);
        // 发起通知
        pthread_cond_signal(&cond);
        sleep(rand() % 4);
    }
    return NULL;
}

void *thr_customer(void *arg){
    ProdInfo *prod = NULL;
    while(1){
        pthread_mutex_lock(&mutex);     // 先加锁
        while(head == NULL) {           // 可能会被虚假唤醒，所以最好while循环判断，而不是if
            printf("消费者%d到达\n", *(int *)arg);
            pthread_cond_wait(&cond, &mutex);	// 如果条件不满足，会阻塞且释放当前锁
        }
        prod = head;
        head = head->next;
        printf("消费者%d, %04d\n", *(int *)arg, prod->num);
        pthread_mutex_unlock(&mutex);
        sleep(rand() % 4);
        free(prod);
    }
    return NULL;
}
int main(void) {
    pthread_t tid[6];
    for(int i = 0; i < 1; i++){
        int *arg = malloc(sizeof(int));
        *arg = i;
        pthread_create(&tid[i], NULL, thr_productor, (void *)arg);
    }
    for(int i = 1; i < 6; i++){
        int *arg = malloc(sizeof(int));
        *arg = i;
        pthread_create(&tid[i], NULL, thr_customer, (void *)arg);
    }
    for(int i = 0; i < 6; i++){
        pthread_join(tid[i], NULL);
    }
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    return 0;
}
```

##### 信号量

```c
#include <semaphore.h>

/**
  * @brief 	初始化一个信号量
  *	@param  sem		信号量
  *	@param  pshared	作用域，取0多个线程共享，非0多个进程共享
  *	@param  value	信号量初值
  * @retval 成功时返回0，失败返回-1，设置errno
  */
int sem_init(sem_t *sem, int pshared, unsigned int value);

/**
  * @brief 	销毁一个信号量
  *	@param  sem		信号量
  * @retval 成功时返回0，失败返回-1，设置errno
  */
int sem_destroy(sem_t *sem);

/**
  * @brief 	将信号量--，信号量为0时加锁
  *	@param  sem		信号量
  * @retval 成功时返回0，失败返回-1，设置errno
  */
int sem_wait(sem_t *sem);

/**
  * @brief 	如果不能立即执行递减，则调用会立即返回一个错误而不是阻塞
  *	@param  sem		信号量
  * @retval 成功时返回0，失败返回-1，设置errno
  */
int sem_trywait(sem_t *sem);

/**
  * @brief 	限时等待
  *	@param  sem				信号量
  *	@param  abs_timeout		等待的绝对时间
  * @retval 成功时返回0，失败返回-1，设置errno
  */
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);

/**
  * @brief 	将信号量++，信号量为0时唤醒阻塞的进程
  *	@param  sem		信号量
  * @retval 成功时返回0，失败返回-1，设置errno
  */
int sem_post(sem_t *sem);
```

```c
// 生产者-消费者模型
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#include <string.h>

#define _SEM_CNT_ 5

sem_t blank, full;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

int begin_num = 1000;

typedef struct _ProdInfo{
    int num;
    struct _ProdInfo *next;
}ProdInfo;

ProdInfo *head = NULL;
int product = 0;

void *thr_productor(void *arg){
    // 负责在链表添加数据
    while(1){
        // 临界区可以让多个进程进入
        sem_wait(&blank);
        // 准备的产品具有唯一性，可以加mutex
        pthread_mutex_lock(&mutex);
        ProdInfo *prod = malloc(sizeof(ProdInfo));
        prod->num = begin_num++;
        // 添加产品
        prod->next = head;
        head = prod;
        product++;
        printf("生产者：%d, %04d, 容量：%d\n", *(int *)arg, prod->num, product);
        pthread_mutex_unlock(&mutex);
        // 其他消耗时间的事情
        sleep(rand() % 3);
        sem_post(&full);
    }
    return NULL;
}

void *thr_customer(void *arg){
    ProdInfo *prod = NULL;
    while(1){
        sem_wait(&full);
        pthread_mutex_lock(&mutex);
        prod = head;
        head = head->next;
        product--;
        printf("消费者：%d, %04d, 容量：%d\n", *(int *)arg, prod->num, product);
        pthread_mutex_unlock(&mutex);
        sleep(rand() % 10 + 5);
        sem_post(&blank);
        free(prod);
    }
    return NULL;
}
int main(void) {
    sem_init(&blank, 0, _SEM_CNT_);
    sem_init(&full, 0, 0);
    pthread_t tid[6];
    for(int i = 0; i < 5; i++){
        int *arg = malloc(sizeof(int));
        *arg = i;
        pthread_create(&tid[i], NULL, thr_productor, (void *)arg);
    }
    for(int i = 5; i < 6; i++){
        int *arg = malloc(sizeof(int));
        *arg = i;
        pthread_create(&tid[i], NULL, thr_customer, (void *)arg);
    }
    for(int i = 0; i < 6; i++){
        pthread_join(tid[i], NULL);
    }
    pthread_mutex_destroy(&mutex);
    return 0;
}
```

```c
// 文件锁单开进程
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define _FILE_NAME_ "/home/doraemon/Code/temp.lock"

int main(void) {
    int fd = open(_FILE_NAME_, O_RDWR);
    if(fd < 0){
        perror("open err");
    }
    // 设置文件的锁属性
    struct flock lk;
    lk.l_type = F_WRLCK;
    lk.l_whence = SEEK_SET;
    lk.l_start = 0;
    lk.l_len = 0;
    // 对文件加锁
    if(fcntl(fd, F_SETLK, &lk) < 0){
        perror("get lock err");
        exit(1);
    }
    while(1){
        printf("I am alive\n");
        sleep(2);
    }
    return 0;
}
```

### 线程基础

#### 简介

本文主要介绍C++11下的线程的基本管控，包括线程的发起、等待、异常条件下如何等待以及后台运作等基础操作

#### 线程发起

顾名思义，线程发起就是启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。如下即可发起一个线程

```c++
void thread_work(std::string str)
{
    std::cout << "str is " << str << std::endl;
}
// 通过()初始化并启动一个线程
std::thread t1(thread_work, "hello");
```

#### 线程等待

当启动一个线程，线程可能没有立刻执行，如果在局部作用域启动了一个线程，或者在main函数里面，很可能子线程没有运行就已经被回收了，回收时会调用线程的析构函数，执行terminate

所以为了防止主线程退出或者局部作用域结束导致子线程被析构的情况，可以通过join，让主线程等待子线程启动运行，子线程运行结束后主线程再运行

```c++
// 通过()初始化并启动一个线程
std::thread t1(thread_work, "hello");
// 主线程等待子线程退出
t1.join();
```

#### 仿函数作为参数

当我们用仿函数作为参数传递给线程时，也可以达到启动线程执行某种操作的含义

```c
class background_task
{
public:
	void operator()(string str)
	{
		cout << "str is " << str << endl;
	}
};

int main()
{
    // 创建了 background_task 类的一个实例，这个实例被用作线程的可调用对象
    // 线程在启动时会调用这个实例的 operator() 方法，并将 "hello" 字符串作为参数传递给它
	thread t1(background_task(), "hello");
	t1.join();
}
```

#### lambda表达式作为参数

```c
int main()
{
	thread t1([](string str) {
		cout << "str is " << endl; 
	}, "hello");
	t1.join();
}
```

#### 线程detach

线程允许采用分离的方式在后台独自运行，调用线程不等待被调用线程，资源在后台线程完成后自动释放

```c
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

void threadFunction()
{
	for (int i = 0; i < 5; ++i)
	{
		cout << "Thread running: " << i << endl;
		this_thread::sleep_for(chrono::seconds(1));
	}
}

int main()
{
	thread t(threadFunction);
	t.detach();

	cout << "Main thread will sleep for 2 seconds" << endl;
	this_thread::sleep_for(chrono::seconds(2));

	cout << "Main thread ending" << endl;
	return 0;
}
```

#### 异常处理

当我们启动一个线程后，如果主线程产生崩溃，会导致子线程也会异常退出，就是调用terminate，如果子线程在进行一些重要的操作比如将充值信息入库等，丢失这些信息是很危险的。所以常用的做法是捕获异常，并且在异常情况下保证子线程稳定运行结束后，主线程抛出异常结束运行

```c
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

class thread_guard
{
private:
	thread &_t;

public:
	explicit thread_guard(thread &t) : _t(t) {}
	~thread_guard()
	{
		// joinable 检查一个线程对象是否可以被 join
		if (_t.joinable())
		{
			_t.join();
		}
	}
	thread_guard(thread_guard const &) = delete;
	thread_guard &operator=(thread_guard const &) = delete;
};

int main()
{
	thread t([]() {
		for (int i = 0; i < 5; ++i)
		{
			cout << "Thread running: " << i << endl;
			this_thread::sleep_for(chrono::seconds(1));
		}
	});
	thread_guard g(t);
	return 0;
}
```

#### 

