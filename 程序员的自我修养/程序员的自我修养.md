## 静态链接

### 编译过程

#### 预编译

处理源文件中以 “#” 开始的预编译指令，生成预编译文件，.c文件对应预编译文件后缀名是.i，而.cpp文件对应后缀名则是.ii

```c++
g++ -E hello.cpp -o hello.ii
```

主要处理规则如下：

-   删除所有 #define ，并展开所有的宏定义
-   处理所有的条件预编译指令，比如 #if，#ifdef，#elif，#else，#endif
-   处理 #include 预编译指令，将被包含的文件递归插入到预编译指令的位置
-   删除所有的注释 // 和 /**/
-   添加行号和文件名标识，以便在编译时编译器能产生调试用的行号信息及编译时报错或者警告能够显示行号
-   保留所有的 #pragma 编译器指令，因为后续编译器还需要

#### 编译

对预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后，生成对应的汇编代码文件

```c++
g++ -S hello.ii -o hello.s
```

#### 汇编

将汇编代码转变成机器可执行的指令，每一条汇编语句都对应一条机器指令，所以汇编过程只需要根据汇编指令和机器指令的对照表一一对应即可

```bas
// 汇编器as
as hello.s -o hello.o

// g++
g++ -c hello.s -o hello.o
```

#### 链接

将多个目标文件链接起来，生成可执行文件

### 编译器

#### 词法分析

将源代码进行扫描，运用有限状态机的算法将源代码的字符序列分割成一系列的记号。词法分析产生的记号一般分为以下几类：关键字、标识符、字面量（数字、字符串等）和特殊符号（如加号、等号），同时，将字符放入对应的表中，方便后续使用

#### 语法分析

对词法分析后的记号进行语法分析，产生语法树。整个过程采用了上下文无关语法的分析手段

#### 语义分析

语法分析只是完成了对表达式的语法层面的分析，但不能代表语句是有意义的。编译器能分析的语义是静态语义，即在编译期间可以确定的语义，而与之对应的动态语义只有在运行期间才能确定

静态语义通常包括声明和类型的匹配，类型的转换。经过语义分析，整个语法树的表达式都被标明了类型，如果存在隐式转换，则语法树会被插入对应的转换节点

#### 中间语言生成

源码级优化器会在源代码级别有一个优化过程，将整个语法树转换成中间代码，转换过程可以用三地址码或P-Code。最基本的三地址码：x = y op z

中间代码使得编译器的工作可以被分为前端和后端。编译器前端负责生成机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。对于跨平台的编译器而言，可以针对不同的平台使用同一个前端和针对不同平台的后端

#### 目标代码生成及优化

编译器后端主要包括代码生成器和目标代码优化器。代码生成器将中间代码转换成目标机器代码，该过程依赖于目标机器，因为不同机器有不同的字长、寄存器等。最后目标代码优化器对生成的目标代码进行优化

### 模块拼装——静态链接

将源代码模块独立地编译，这个组装模块的过程就是链接。链接过程主要包括了地址和空间分配、符号决议和重定位这些步骤。

整个链接过程可以理解为，假设在main.c文件里面用到fun.c文件里面的函数foo()，那么在生成目标文件过程中，main.o文件并不知道foo的地址，只有通过链接才能填入正确的foo地址。用于多个文件的全局变量也是如此。

## 目标文件

### 目标文件格式

主要分为Windows下的PE（Portable Executable）和Linux的ELF（Executable Linkable Format），都是COFF（Common file format）格式的变种。目标文件就是源代码编译后但没有进行链接的中间文件，与可执行文件的内容和结构很相似，一般用同一种结构存储。

除此之外，动态链接库（DLL，Dynamic Linking Library）和静态链接库（Static Linking Library）文件都按可执行文件格式存储

### 目标文件结构

-   File Header：描述整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，还有一个段表，描述文件中各个段在文件中的偏移位置及段的属性等
-   .text：代码段，存放编译后的执行语句
-   .data：已经初始化的全局变量和局部静态变量
-   .bss：未初始化的全局变量和局部静态变量，该段并没有内容，只是为暂未初始化的数据预留空间
-   .rodata：只读数据，即只读变量和字符串常量（有时候编译器将字符串常量存到.data段）

数据和指令分段好处：

-   数据区域可读写，指令区域不可读写，划分后可设置不同读写权限
-   有助于提高程序的局部性，提高缓存命中率
-   当系统中运行着多个该程序的副本时，只需要保存一份即可，节约内存

```bash
gcc -c main.c	# 生成目标文件
objdump -h main.o	# 将各个段的基本信息打印出来
objdump -s -d main.o	# 将所有段的内容以16进制方式打印，且将所有包含指令的段反汇编
```

```c++
// __attribute__((section(name))) 全局变量或函数 将指定数据存到以"name"作为段名的段中
__attribute__((section("FOO"))) int b = 2;
```

